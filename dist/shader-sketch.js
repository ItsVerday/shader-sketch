!function(n){var e={};function t(o){if(e[o])return e[o].exports;var r=e[o]={i:o,l:!1,exports:{}};return n[o].call(r.exports,r,r.exports,t),r.l=!0,r.exports}t.m=n,t.c=e,t.d=function(n,e,o){t.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:o})},t.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},t.t=function(n,e){if(1&e&&(n=t(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var o=Object.create(null);if(t.r(o),Object.defineProperty(o,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var r in n)t.d(o,r,function(e){return n[e]}.bind(null,r));return o},t.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return t.d(e,"a",e),e},t.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},t.p="",t(t.s=25)}([function(n,e,t){"use strict";t.r(e),e.default="const float PI = 3.1415926535897932384626433832795;\n\nfloat map(float value, float a1, float a2, float b1, float b2) {\n    return (value - a1) / (a2 - a1) * (b2 - b1) + b1;\n}"},function(n,e,t){"use strict";t.r(e),e.default="struct RayMarch {\n    int iterations;\n    int maxIterations;\n    vec3 position;\n    vec3 direction;\n    float epsilon;\n    bool finished;\n    bool hit;\n    float smallestDistance;\n    vec3 closestPosition;\n    float emission;\n};\n\nRayMarch create_raymarch(vec3 position, vec3 direction, int maxIterations) {\n    return RayMarch(0, maxIterations, position, direction, 0.0001, false, false, 999999999., vec3(0., 0., 0.), 0.);\n}\n\nRayMarch iterate_raymarch(RayMarch rayMarch, float sdf) {\n    rayMarch.iterations++;\n\n    if (sdf < rayMarch.epsilon) {\n        rayMarch.finished = true;\n        rayMarch.hit = true;\n        return rayMarch;\n    }\n\n    if (rayMarch.iterations > rayMarch.maxIterations) {\n        rayMarch.finished = true;\n        return rayMarch;\n    }\n\n    rayMarch.position += normalize(rayMarch.direction) * sdf;\n    float emission = 1. / (sdf + 1.);\n\n    if (rayMarch.emission < emission) {\n        rayMarch.emission = emission;\n    }\n\n    if (sdf < rayMarch.smallestDistance) {\n        rayMarch.smallestDistance = sdf;\n        rayMarch.closestPosition = rayMarch.position;\n    }\n    \n    return rayMarch;\n}\n\nvec3 raymarch_normal(float center, float x, float y, float z) {\n    return normalize(vec3(center - x, center - y, center - z));\n}\n\nfloat raymarch_ambient_occlusion(RayMarch rayMarch, float intensity) {\n    return pow(1. - intensity, float(rayMarch.iterations));\n}\n\nfloat raymarch_emission(RayMarch rayMarch, float limit, float intensity) {\n    return limit * intensity * (2. / (1. + exp(-rayMarch.emission / limit)) - 1.);\n}"},function(n,e,t){"use strict";t.r(e),e.default="vec3 camera_look(float yaw, float pitch, float fov, float aspectRatio, vec2 screenPos) {\n    screenPos = screenPos * 2. - 1.;\n    pitch = pitch * PI / 180.;\n    yaw = yaw * PI / 180.;\n\n    fov /= 2.;\n\n    vec3 forward = vec3(cos(yaw) * cos(pitch), sin(pitch), sin(yaw) * cos(pitch));\n    vec3 up = vec3(cos(yaw) * cos(pitch + PI / 2.), sin(pitch + PI / 2.), sin(yaw) * cos(pitch + PI / 2.));\n    vec3 right = cross(forward, up);\n\n    screenPos.y /= aspectRatio;\n    float fovScale = tan(fov * PI / 180.);\n\n    up *= fovScale;\n    right *= fovScale;\n\n    return normalize(forward + right * screenPos.x + up * screenPos.y);\n}"},function(n,e,t){"use strict";t.r(e),e.default='[\n    "clover_noise_2d",\n    "clover_noise_3d"\n]'},function(n,e,t){"use strict";t.r(e),e.default="const float CLOVER_NOISE_2D_POINT_SPREAD = .3;\nconst float CLOVER_NOISE_2D_PI = radians(180.);\n\nfloat clover_noise_2d_hash(vec2 p) {\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nvec2 clover_noise_2d_offset(vec2 p, float hash) {\n    vec2 offset = vec2(sin(hash * PI * 100.), cos(hash * PI * 100.)) * floor(hash * 50. + 1.) * .01 + .5;\n    return p + offset * CLOVER_NOISE_2D_POINT_SPREAD * 2. + .5 - CLOVER_NOISE_2D_POINT_SPREAD;\n}\n\n/**\n * Finds the value of 2D clover noise at a certain location.\n *\n * @param vec2 p The 2D vector where clover noise will be calculated at.\n * @return float The value of clover noise at p, the 2D vector.\n */\nfloat clover_noise_2d(vec2 p) {\n    vec2 p_floor = floor(p);\n\n    vec2 c_11 = clover_noise_2d_offset(p_floor, clover_noise_2d_hash(p_floor));\n    vec2 c_10 = p_floor + vec2(0, -1);\n    c_10 = clover_noise_2d_offset(c_10, clover_noise_2d_hash(c_10));\n    vec2 c_12 = p_floor + vec2(0, 1);\n    c_12 = clover_noise_2d_offset(c_12, clover_noise_2d_hash(c_12));\n    vec2 c_01 = p_floor + vec2(-1, 0);\n    c_01 = clover_noise_2d_offset(c_01, clover_noise_2d_hash(c_01));\n    vec2 c_21 = p_floor + vec2(1, 0);\n    c_21 = clover_noise_2d_offset(c_21, clover_noise_2d_hash(c_21));\n\n    vec2 d_p_c11 = (p - c_11).yx;\n    vec2 m_p_c11 = d_p_c11 * c_11;\n\n    vec2 side_nx = m_p_c11 - d_p_c11 * c_01;\n    vec2 side_px = m_p_c11 - d_p_c11 * c_21;\n\n    vec2 a, c, d;\n\n    if ((side_nx.y - side_nx.x < 0. && p.x < c_11.x) || (side_px.y - side_px.x > 0. && p.x >= c_11.x)) {\n        vec2 side_py = m_p_c11 - d_p_c11 * c_12;\n\n        if (side_py.y - side_py.x > 0.) {\n            a = c_12;\n            c = c_01;\n            d = vec2(-1, 1);\n        } else {\n            a = c_21;\n            c = c_12;\n            d = vec2(1, 1);\n        }\n    } else {\n        vec2 side_ny = m_p_c11 - d_p_c11 * c_10;\n\n        if (side_ny.y - side_ny.x > 0.) {\n            a = c_10;\n            c = c_21;\n            d = vec2(1, -1);\n        } else {\n            a = c_01;\n            c = c_10;\n            d = vec2(-1, -1);\n        }\n    }\n\n    d = clover_noise_2d_offset(p_floor + d, clover_noise_2d_hash(p_floor + d));\n\n    vec2 f = a;\n    vec2 g = c;\n    vec2 h = d;\n\n    vec2 ac = a - c;\n    vec2 bd = c_11 - d;\n\n    if (ac.x * ac.x + ac.y * ac.y < bd.x * bd.x + bd.y * bd.y) {\n        vec2 pa = p - a;\n\n        if (pa.x * ac.y - pa.y * ac.x > 0.) {\n            h = c_11;\n        }\n    } else {\n        vec2 pb = p - c_11;\n\n        if (pb.x * bd.y - pb.y * bd.x > 0.) {\n            f = c_11;\n        } else {\n            g = c_11;\n        }\n    }\n\n    vec2 bc_v0 = g - f;\n    vec2 bc_v1 = h - f;\n    vec2 bc_v2 = p - f;\n    float den = 1. / (bc_v0.x * bc_v1.y - bc_v1.x * bc_v0.y);\n    float v = (bc_v2.x * bc_v1.y - bc_v1.x * bc_v2.y) * den;\n    float w = (bc_v0.x * bc_v2.y - bc_v2.x * bc_v0.y) * den;\n    float u = 1. - v - w;\n\n    v = v * v * v;\n    w = w * w * w;\n    u = u * u * u;\n    float s = 1. / (u + v + w);\n    v *= s;\n    w *= s;\n    u *= s;\n\n    float fv = clover_noise_2d_hash(f);\n    float gv = clover_noise_2d_hash(g);\n    float hv = clover_noise_2d_hash(h);\n\n    return u * fv + v * gv + w * hv;\n}\n\n/**\n * Finds the value of 2D fractal clover noise at a certain location.\n *\n * @param vec2 p The 2D vector where fractal clover noise will be calculated at.\n * @param int iterations The amount of iterations to perform for fractal noise. Capped at 10.\n * @return float The value of fractal clover noise at p, the 2D vector.\n */\nfloat fractal_clover_noise_2d(vec2 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n    float invScale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += clover_noise_2d(p * invScale) * scale;\n        divide += scale;\n        \n        scale *= .4;\n        invScale *= 2.5;\n    }\n\n    return total / divide;\n}\n\n/**\n * Finds the value of 2D curl clover noise at a certain location.\n *\n * @param vec2 p The 2D vector where fractal clover noise will be calculated at.\n * @return vec2 The value of curl clover noise at p, the 2D vector.\n */\nvec2 curl_clover_noise_2d(vec2 p) {\n    const float DX = 0.01;\n\n    float v = clover_noise_2d(p);\n    float x = clover_noise_2d(p + vec2(DX, 0.));\n    float y = clover_noise_2d(p + vec2(0., DX));\n    return normalize(vec2(v - x, v - y));\n}\n\n/**\n * Finds the value of 2D curl fractal clover noise at a certain location.\n *\n * @param vec2 p The 2D vector where curl fractal clover noise will be calculated at.\n * @param int iterations The amount of iterations to perform for fractal noise. Capped at 10.\n * @return vec2 The value of curl fractal clover noise at p, the 2D vector.\n */\nvec2 curl_fractal_clover_noise_2d(vec2 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_clover_noise_2d(p, iterations);\n    float x = fractal_clover_noise_2d(p + vec2(DX, 0.), iterations);\n    float y = fractal_clover_noise_2d(p + vec2(0., DX), iterations);\n    return normalize(vec2(v - x, v - y));\n}"},function(n,e,t){"use strict";t.r(e),e.default="const float CLOVER_NOISE_3D_POINT_SPREAD = .2;\nconst float CLOVER_NOISE_3D_PI = radians(180.);\n\nfloat clover_noise_3d_hash(vec3 p) {\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x - p.z)) * sin(12.0 * p.z - sin(p.x * 10.0))));\n}\n\nvec3 clover_noise_3d_offset(vec3 p, float hash) {\n    float rotation = hash * PI * 2000.;\n    float height = (fract((floor(hash * 1000.) + .5) / 100.) - .5) * PI / 2.;\n    float layer = floor(hash * 10. + 1.) * .1;\n    vec3 offset = vec3(sin(rotation) * cos(height), sin(height), cos(rotation) * cos(height)) * layer + .5;\n    return p + offset * CLOVER_NOISE_3D_POINT_SPREAD * 2. + .5 - CLOVER_NOISE_3D_POINT_SPREAD;\n}\n\nbool clover_noise_3d_boundary(vec3 p, vec3 c_00, vec3 c_10, vec3 c_20, vec3 c_01, vec3 c_11, vec3 c_21, vec3 c_02, vec3 c_12, vec3 c_22) {\n    vec2 d_p_c11 = p.yx - c_11.yx;\n    vec2 m_p_c11 = d_p_c11 * c_11.xy;\n\n    vec2 side_nx = m_p_c11 - d_p_c11 * c_01.xy;\n    vec2 side_px = m_p_c11 - d_p_c11 * c_21.xy;\n\n    vec3 a, b, c, d;\n\n    if ((side_nx.y - side_nx.x < 0. && p.x < c_11.x) || (side_px.y - side_px.x > 0. && p.x >= c_11.x)) {\n        vec2 side_py = m_p_c11 - d_p_c11 * c_12.xy;\n\n        if (side_py.y - side_py.x > 0.) {\n            a = c_01;\n            b = c_02;\n            c = c_12;\n            d = c_11;\n        } else {\n            a = c_11;\n            b = c_12;\n            c = c_22;\n            d = c_21;\n        }\n    } else {\n        vec2 side_ny = m_p_c11 - d_p_c11 * c_10.xy;\n\n        if (side_ny.y - side_ny.x > 0.) {\n            a = c_10;\n            b = c_11;\n            c = c_21;\n            d = c_20;\n        } else {\n            a = c_00;\n            b = c_01;\n            c = c_11;\n            d = c_10;\n        }\n    }\n\n    vec3 f = a;\n    vec3 g = c;\n    vec3 h = d;\n\n    vec3 ac = a - c;\n    vec3 pa = p - a;\n\n    if (pa.x * ac.y - pa.y * ac.x > 0.) {\n        h = b;\n    }\n\n    vec2 bc_v0 = g.xy - f.xy;\n    vec2 bc_v1 = h.xy - f.xy;\n    vec2 bc_v2 = p.xy - f.xy;\n    float den = 1. / (bc_v0.x * bc_v1.y - bc_v1.x * bc_v0.y);\n    float v = (bc_v2.x * bc_v1.y - bc_v1.x * bc_v2.y) * den;\n    float w = (bc_v0.x * bc_v2.y - bc_v2.x * bc_v0.y) * den;\n    float u = 1. - v - w;\n\n    return p.z < u * f.z + v * g.z + w * h.z;\n}\n\n/**\n * Finds the value of 3D clover noise at a certain location.\n *\n * @param vec3 p The 3D vector where clover noise will be calculated at.\n * @return float The value of clover noise at p, the 3D vector.\n */\nfloat clover_noise_3d(vec3 p) {\n    vec3 p_floor = floor(p);\n\n    vec3 c_111 = clover_noise_3d_offset(p_floor, clover_noise_3d_hash(p_floor));\n    vec3 c_100 = p_floor + vec3(0, -1, -1);\n    c_100 = clover_noise_3d_offset(c_100, clover_noise_3d_hash(c_100));\n    vec3 c_010 = p_floor + vec3(-1, 0, -1);\n    c_010 = clover_noise_3d_offset(c_010, clover_noise_3d_hash(c_010));\n    vec3 c_110 = p_floor + vec3(0, 0, -1);\n    c_110 = clover_noise_3d_offset(c_110, clover_noise_3d_hash(c_110));\n    vec3 c_210 = p_floor + vec3(1, 0, -1);\n    c_210 = clover_noise_3d_offset(c_210, clover_noise_3d_hash(c_210));\n    vec3 c_120 = p_floor + vec3(0, 1, -1);\n    c_120 = clover_noise_3d_offset(c_120, clover_noise_3d_hash(c_120));\n    vec3 c_001 = p_floor + vec3(-1, -1, 0);\n    c_001 = clover_noise_3d_offset(c_001, clover_noise_3d_hash(c_001));\n    vec3 c_101 = p_floor + vec3(0, -1, 0);\n    c_101 = clover_noise_3d_offset(c_101, clover_noise_3d_hash(c_101));\n    vec3 c_201 = p_floor + vec3(1, -1, 0);\n    c_201 = clover_noise_3d_offset(c_201, clover_noise_3d_hash(c_201));\n    vec3 c_011 = p_floor + vec3(-1, 0, 0);\n    c_011 = clover_noise_3d_offset(c_011, clover_noise_3d_hash(c_011));\n    vec3 c_211 = p_floor + vec3(1, 0, 0);\n    c_211 = clover_noise_3d_offset(c_211, clover_noise_3d_hash(c_211));\n    vec3 c_021 = p_floor + vec3(-1, 1, 0);\n    c_021 = clover_noise_3d_offset(c_021, clover_noise_3d_hash(c_021));\n    vec3 c_121 = p_floor + vec3(0, 1, 0);\n    c_121 = clover_noise_3d_offset(c_121, clover_noise_3d_hash(c_121));\n    vec3 c_221 = p_floor + vec3(1, 1, 0);\n    c_221 = clover_noise_3d_offset(c_221, clover_noise_3d_hash(c_221));\n    vec3 c_102 = p_floor + vec3(0, -1, 1);\n    c_102 = clover_noise_3d_offset(c_102, clover_noise_3d_hash(c_102));\n    vec3 c_012 = p_floor + vec3(-1, 0, 1);\n    c_012 = clover_noise_3d_offset(c_012, clover_noise_3d_hash(c_012));\n    vec3 c_112 = p_floor + vec3(0, 0, 1);\n    c_112 = clover_noise_3d_offset(c_112, clover_noise_3d_hash(c_112));\n    vec3 c_212 = p_floor + vec3(1, 0, 1);\n    c_212 = clover_noise_3d_offset(c_212, clover_noise_3d_hash(c_212));\n    vec3 c_122 = p_floor + vec3(0, 1, 1);\n    c_122 = clover_noise_3d_offset(c_122, clover_noise_3d_hash(c_122));\n\n    bool x_bound = clover_noise_3d_boundary(p.yzx, c_100.yzx, c_110.yzx, c_120.yzx, c_101.yzx, c_111.yzx, c_121.yzx, c_102.yzx, c_112.yzx, c_122.yzx);\n    bool y_bound = clover_noise_3d_boundary(p.xzy, c_010.xzy, c_110.xzy, c_210.xzy, c_011.xzy, c_111.xzy, c_211.xzy, c_012.xzy, c_112.xzy, c_212.xzy);\n    bool z_bound = clover_noise_3d_boundary(    p,     c_001,     c_101,     c_201,     c_011,     c_111,     c_211,     c_021,     c_121,     c_221);\n\n    vec3 a, b, c, d, e, f, g, h;\n\n    if (x_bound) {\n        if (y_bound) {\n            if (z_bound) {\n                a = p_floor + vec3(-1, -1, -1);\n                b = c_001;\n                c = c_010;\n                d = c_011;\n                e = c_100;\n                f = c_101;\n                g = c_110;\n                h = c_111;\n\n                a = clover_noise_3d_offset(a, clover_noise_3d_hash(a));\n            } else {\n                a = c_001;\n                b = p_floor + vec3(-1, -1, 1);\n                c = c_011;\n                d = c_012;\n                e = c_101;\n                f = c_102;\n                g = c_111;\n                h = c_112;\n\n                b = clover_noise_3d_offset(b, clover_noise_3d_hash(b));\n            }\n        } else {\n            if (z_bound) {\n                a = c_010;\n                b = c_011;\n                c = p_floor + vec3(-1, 1, -1);\n                d = c_021;\n                e = c_110;\n                f = c_111;\n                g = c_120;\n                h = c_121;\n\n                c = clover_noise_3d_offset(c, clover_noise_3d_hash(c));\n            } else {\n                a = c_011;\n                b = c_012;\n                c = c_021;\n                d = p_floor + vec3(-1, 1, 1);\n                e = c_111;\n                f = c_112;\n                g = c_121;\n                h = c_122;\n\n                d = clover_noise_3d_offset(d, clover_noise_3d_hash(d));\n            }\n        }\n    } else {\n        if (y_bound) {\n            if (z_bound) {\n                a = c_100;\n                b = c_101;\n                c = c_110;\n                d = c_111;\n                e = p_floor + vec3(1, -1, -1);\n                f = c_201;\n                g = c_210;\n                h = c_211;\n\n                e = clover_noise_3d_offset(e, clover_noise_3d_hash(e));\n            } else {\n                a = c_101;\n                b = c_102;\n                c = c_111;\n                d = c_112;\n                e = c_201;\n                f = p_floor + vec3(1, -1, 1);\n                g = c_211;\n                h = c_212;\n\n                f = clover_noise_3d_offset(f, clover_noise_3d_hash(f));\n            }\n        } else {\n            if (z_bound) {\n                a = c_110;\n                b = c_111;\n                c = c_120;\n                d = c_121;\n                e = c_210;\n                f = c_211;\n                g = p_floor + vec3(1, 1, -1);\n                h = c_221;\n\n                g = clover_noise_3d_offset(g, clover_noise_3d_hash(g));\n            } else {\n                a = c_111;\n                b = c_112;\n                c = c_121;\n                d = c_122;\n                e = c_211;\n                f = c_212;\n                g = c_221;\n                h = p_floor + vec3(1, 1, 1);\n\n                h = clover_noise_3d_offset(h, clover_noise_3d_hash(h));\n            }\n        }\n    }\n\n    vec3 ah = a - h;\n    vec3 pa = p - a;\n    \n    vec3 plane_b_sum = cross(ah, b - h) * pa;\n    float plane_b = plane_b_sum.x + plane_b_sum.y + plane_b_sum.z;\n    vec3 plane_c_sum = cross(ah, c - h) * pa;\n    float plane_c = plane_c_sum.x + plane_c_sum.y + plane_c_sum.z;\n    vec3 plane_d_sum = cross(ah, d - h) * pa;\n    float plane_d = plane_d_sum.x + plane_d_sum.y + plane_d_sum.z;\n    vec3 plane_e_sum = cross(ah, e - h) * pa;\n    float plane_e = plane_e_sum.x + plane_e_sum.y + plane_e_sum.z;\n    vec3 plane_f_sum = cross(ah, f - h) * pa;\n    float plane_f = plane_f_sum.x + plane_f_sum.y + plane_f_sum.z;\n    vec3 plane_g_sum = cross(ah, g - h) * pa;\n    float plane_g = plane_g_sum.x + plane_g_sum.y + plane_g_sum.z;\n\n    vec3 i, j, k, l;\n    i = a;\n    j = h;\n\n    if (plane_b > 0. && plane_d <= 0.) {\n        k = b;\n        l = d;\n    } else if (plane_d > 0. && plane_c <= 0.) {\n        k = d;\n        l = c;\n    } else if (plane_c > 0. && plane_g <= 0.) {\n        k = c;\n        l = g;\n    } else if (plane_g > 0. && plane_e <= 0.) {\n        k = g;\n        l = e;\n    } else if (plane_e > 0. && plane_f <= 0.) {\n        k = e;\n        l = f;\n    } else {\n        k = f;\n        l = b;\n    }\n\n    vec3 bc_ap = p - i;\n    vec3 bc_bp = p - j;\n\n    vec3 bc_ab = j - i;\n    vec3 bc_ac = k - i;\n    vec3 bc_ad = l - i;\n\n    vec3 bc_bc = k - j;\n    vec3 bc_bd = l - j;\n\n    float bc_va6 = dot(bc_bp, cross(bc_bd, bc_bc));\n    float bc_vb6 = dot(bc_ap, cross(bc_ac, bc_ad));\n    float bc_vc6 = dot(bc_ap, cross(bc_ad, bc_ab));\n    float bc_vd6 = dot(bc_ap, cross(bc_ab, bc_ac));\n    float bc_v6 = 1. / dot(bc_ab, cross(bc_ac, bc_ad));\n\n    float v = bc_va6 * bc_v6;\n    float w = bc_vb6 * bc_v6;\n    float t = bc_vc6 * bc_v6;\n    float u = bc_vd6 * bc_v6;\n    \n    float fiu = u * u * u * (1. - v * w * t);\n    float fiv = v * v * v * (1. - u * w * t);\n    float fiw = w * w * w * (1. - v * u * t);\n    float fit = t * t * t * (1. - v * w * u);\n    float s = fiu + fiv + fiw + fit;\n    fiu /= s;\n    fiv /= s;\n    fiw /= s;\n    fit /= s;\n\n    float iv = clover_noise_3d_hash(i);\n    float jv = clover_noise_3d_hash(j);\n    float kv = clover_noise_3d_hash(k);\n    float lv = clover_noise_3d_hash(l);\n    \n    return fiv * iv + fiw * jv + fit * kv + fiu * lv;\n}\n\n/**\n * Finds the value of 3D fractal clover noise at a certain location.\n *\n * @param vec3 p The 3D vector where fractal clover noise will be calculated at.\n * @param int iterations The amount of iterations to perform for fractal noise. Capped at 10.\n * @return float The value of fractal clover noise at p, the 3D vector.\n */\nfloat fractal_clover_noise_3d(vec3 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n    float invScale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += clover_noise_3d(p * invScale) * scale;\n        divide += scale;\n        \n        scale *= .4;\n        invScale *= 2.5;\n    }\n\n    return total / divide;\n}\n\n/**\n * Finds the value of 3D curl clover noise at a certain location.\n *\n * @param vec3 p The 3D vector where fractal clover noise will be calculated at.\n * @return vec3 The value of curl clover noise at p, the 3D vector.\n */\nvec3 curl_clover_noise_3d(vec3 p) {\n    const float DX = 0.01;\n\n    float v = clover_noise_3d(p);\n    float x = clover_noise_3d(p + vec3(DX, 0., 0.));\n    float y = clover_noise_3d(p + vec3(0., DX, 0.));\n    float z = clover_noise_3d(p + vec3(0., 0., DX));\n    return normalize(vec3(v - x, v - y, v - z));\n}\n\n/**\n * Finds the value of 3D curl fractal clover noise at a certain location.\n *\n * @param vec3 p The 3D vector where curl fractal clover noise will be calculated at.\n * @param int iterations The amount of iterations to perform for fractal noise. Capped at 10.\n * @return vec3 The value of curl fractal clover noise at p, the 3D vector.\n */\nvec3 curl_fractal_clover_noise_3d(vec3 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_clover_noise_3d(p, iterations);\n    float x = fractal_clover_noise_3d(p + vec3(DX, 0., 0.), iterations);\n    float y = fractal_clover_noise_3d(p + vec3(0., DX, 0.), iterations);\n    float z = fractal_clover_noise_3d(p + vec3(0., 0., DX), iterations);\n    return normalize(vec3(v - x, v - y, v - z));\n}\n"},function(n,e,t){"use strict";t.r(e),e.default="vec3 RGBtoHSV(vec3 rgb) {\n float Cmax = max(rgb.r, max(rgb.g, rgb.b));\n float Cmin = min(rgb.r, min(rgb.g, rgb.b));\n float delta = Cmax - Cmin;\n\n vec3 hsv = vec3(0., 0., Cmax);\n\n if (Cmax > Cmin) {\n     hsv.y = delta / Cmax;\n\n     if (rgb.r == Cmax)\n         hsv.x = (rgb.g - rgb.b) / delta;\n     else {\n         if (rgb.g == Cmax)\n             hsv.x = 2. + (rgb.b - rgb.r) / delta;\n         else\n             hsv.x = 4. + (rgb.r - rgb.g) / delta;\n     }\n     hsv.x = fract(hsv.x / 6.);\n }\n return hsv;\n}\n\nvec3 HSVtoRGB(vec3 c) {\nvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\nreturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec3 RGBtoHSL(vec3 color) {\n vec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\n float fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\n float fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\n float delta = fmax - fmin; //Delta RGB value\n\n hsl.z = (fmax + fmin) / 2.0; // Luminance\n\n if (delta == 0.0) //This is a gray, no chroma...\n {\n     hsl.x = 0.0; // Hue\n     hsl.y = 0.0; // Saturation\n } else //Chromatic data...\n {\n     if (hsl.z < 0.5)\n         hsl.y = delta / (fmax + fmin); // Saturation\n     else\n         hsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\n     float deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\n     float deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\n     float deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\n     if (color.r == fmax)\n         hsl.x = deltaB - deltaG; // Hue\n     else if (color.g == fmax)\n         hsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\n     else if (color.b == fmax)\n         hsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\n     if (hsl.x < 0.0)\n         hsl.x += 1.0; // Hue\n     else if (hsl.x > 1.0)\n         hsl.x -= 1.0; // Hue\n }\n\n return hsl;\n}\n\nvec3 HSLtoRGB(vec3 c) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0);\n\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}"},function(n,e,t){"use strict";t.r(e),e.default='[\n    "perlin_noise",\n    "simplex_noise",\n    "clover_noise",\n    "voronoise"\n]'},function(n,e,t){"use strict";t.r(e),e.default='[\n    "perlin_noise_2d",\n    "perlin_noise_3d",\n    "perlin_noise_4d"\n]'},function(n,e,t){"use strict";t.r(e),e.default="vec4 perlin_noise_2d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nvec2 perlin_noise_2d_fade(vec2 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat perlin_noise_2d(vec2 P) {\n    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n    Pi = mod(Pi, 289.0); // To avoid truncation effects in permutation\n    vec4 ix = Pi.xzxz;\n    vec4 iy = Pi.yyww;\n    vec4 fx = Pf.xzxz;\n    vec4 fy = Pf.yyww;\n    vec4 i = perlin_noise_2d_permute(perlin_noise_2d_permute(ix) + iy);\n    vec4 gx = 2.0 * fract(i * 0.0243902439) - 1.0; // 1/41 = 0.024...\n    vec4 gy = abs(gx) - 0.5;\n    vec4 tx = floor(gx + 0.5);\n    gx = gx - tx;\n    vec2 g00 = vec2(gx.x,gy.x);\n    vec2 g10 = vec2(gx.y,gy.y);\n    vec2 g01 = vec2(gx.z,gy.z);\n    vec2 g11 = vec2(gx.w,gy.w);\n    vec4 norm = 1.79284291400159 - 0.85373472095314 * \n    vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11));\n    g00 *= norm.x;\n    g01 *= norm.y;\n    g10 *= norm.z;\n    g11 *= norm.w;\n    float n00 = dot(g00, vec2(fx.x, fy.x));\n    float n10 = dot(g10, vec2(fx.y, fy.y));\n    float n01 = dot(g01, vec2(fx.z, fy.z));\n    float n11 = dot(g11, vec2(fx.w, fy.w));\n    vec2 fade_xy = perlin_noise_2d_fade(Pf.xy);\n    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n    return (2.3 * n_xy) / 2. + .5;\n}\n\nfloat fractal_perlin_noise_2d(vec2 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += perlin_noise_2d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec2 curl_perlin_noise_2d(vec2 p) {\n    const float DX = 0.01;\n\n    float v = perlin_noise_2d(p);\n    float x = perlin_noise_2d(p + vec2(DX, 0.));\n    float y = perlin_noise_2d(p + vec2(0., DX));\n    return normalize(vec2(v - x, v - y));\n}\n\nvec2 curl_fractal_perlin_noise_2d(vec2 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_perlin_noise_2d(p, iterations);\n    float x = fractal_perlin_noise_2d(p + vec2(DX, 0.), iterations);\n    float y = fractal_perlin_noise_2d(p + vec2(0., DX), iterations);\n    return normalize(vec2(v - x, v - y));\n}"},function(n,e,t){"use strict";t.r(e),e.default="vec4 perlin_noise_3d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 perlin_noise_3d_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec3 perlin_noise_3d_fade(vec3 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat perlin_noise_3d(vec3 P){\n    vec3 Pi0 = floor(P); // Integer part for indexing\n    vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec3 Pf0 = fract(P); // Fractional part for interpolation\n    vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = perlin_noise_3d_permute(perlin_noise_3d_permute(ix) + iy);\n    vec4 ixy0 = perlin_noise_3d_permute(ixy + iz0);\n    vec4 ixy1 = perlin_noise_3d_permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 / 7.0;\n    vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 / 7.0;\n    vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = perlin_noise_3d_taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = perlin_noise_3d_taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = perlin_noise_3d_fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n    return (2.2 * n_xyz) / 2. + .5;\n}\n\nfloat fractal_perlin_noise_3d(vec3 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += perlin_noise_3d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec3 curl_perlin_noise_3d(vec3 p) {\n    const float DX = 0.01;\n\n    float v = perlin_noise_3d(p);\n    float x = perlin_noise_3d(p + vec3(DX, 0., 0.));\n    float y = perlin_noise_3d(p + vec3(0., DX, 0.));\n    float z = perlin_noise_3d(p + vec3(0., 0., DX));\n    return normalize(vec3(v - x, v - y, v - x));\n}\n\nvec3 curl_fractal_perlin_noise_3d(vec3 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_perlin_noise_3d(p, iterations);\n    float x = fractal_perlin_noise_3d(p + vec3(DX, 0., 0.), iterations);\n    float y = fractal_perlin_noise_3d(p + vec3(0., DX, 0.), iterations);\n    float z = fractal_perlin_noise_3d(p + vec3(0., 0., DX), iterations);\n    return normalize(vec3(v - x, v - y, v - z));\n}"},function(n,e,t){"use strict";t.r(e),e.default="vec4 perlin_noise_4d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 perlin_noise_4d_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nvec4 perlin_noise_4d_fade(vec4 t) { return t*t*t*(t*(t*6.0-15.0)+10.0); }\n\nfloat perlin_noise_4d(vec4 P) {\n    vec4 Pi0 = floor(P); // Integer part for indexing\n    vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n    Pi0 = mod(Pi0, 289.0);\n    Pi1 = mod(Pi1, 289.0);\n    vec4 Pf0 = fract(P); // Fractional part for interpolation\n    vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = vec4(Pi0.zzzz);\n    vec4 iz1 = vec4(Pi1.zzzz);\n    vec4 iw0 = vec4(Pi0.wwww);\n    vec4 iw1 = vec4(Pi1.wwww);\n\n    vec4 ixy = perlin_noise_4d_permute(perlin_noise_4d_permute(ix) + iy);\n    vec4 ixy0 = perlin_noise_4d_permute(ixy + iz0);\n    vec4 ixy1 = perlin_noise_4d_permute(ixy + iz1);\n    vec4 ixy00 = perlin_noise_4d_permute(ixy0 + iw0);\n    vec4 ixy01 = perlin_noise_4d_permute(ixy0 + iw1);\n    vec4 ixy10 = perlin_noise_4d_permute(ixy1 + iw0);\n    vec4 ixy11 = perlin_noise_4d_permute(ixy1 + iw1);\n\n    vec4 gx00 = ixy00 / 7.0;\n    vec4 gy00 = floor(gx00) / 7.0;\n    vec4 gz00 = floor(gy00) / 6.0;\n    gx00 = fract(gx00) - 0.5;\n    gy00 = fract(gy00) - 0.5;\n    gz00 = fract(gz00) - 0.5;\n    vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n    vec4 sw00 = step(gw00, vec4(0.0));\n    gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n    gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n    vec4 gx01 = ixy01 / 7.0;\n    vec4 gy01 = floor(gx01) / 7.0;\n    vec4 gz01 = floor(gy01) / 6.0;\n    gx01 = fract(gx01) - 0.5;\n    gy01 = fract(gy01) - 0.5;\n    gz01 = fract(gz01) - 0.5;\n    vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n    vec4 sw01 = step(gw01, vec4(0.0));\n    gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n    gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n    vec4 gx10 = ixy10 / 7.0;\n    vec4 gy10 = floor(gx10) / 7.0;\n    vec4 gz10 = floor(gy10) / 6.0;\n    gx10 = fract(gx10) - 0.5;\n    gy10 = fract(gy10) - 0.5;\n    gz10 = fract(gz10) - 0.5;\n    vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n    vec4 sw10 = step(gw10, vec4(0.0));\n    gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n    gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n    vec4 gx11 = ixy11 / 7.0;\n    vec4 gy11 = floor(gx11) / 7.0;\n    vec4 gz11 = floor(gy11) / 6.0;\n    gx11 = fract(gx11) - 0.5;\n    gy11 = fract(gy11) - 0.5;\n    gz11 = fract(gz11) - 0.5;\n    vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n    vec4 sw11 = step(gw11, vec4(0.0));\n    gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n    gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n    vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n    vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n    vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n    vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n    vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n    vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n    vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n    vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n    vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n    vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n    vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n    vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n    vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n    vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n    vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n    vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n    vec4 norm00 = perlin_noise_4d_taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n    g0000 *= norm00.x;\n    g0100 *= norm00.y;\n    g1000 *= norm00.z;\n    g1100 *= norm00.w;\n\n    vec4 norm01 = perlin_noise_4d_taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n    g0001 *= norm01.x;\n    g0101 *= norm01.y;\n    g1001 *= norm01.z;\n    g1101 *= norm01.w;\n\n    vec4 norm10 = perlin_noise_4d_taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n    g0010 *= norm10.x;\n    g0110 *= norm10.y;\n    g1010 *= norm10.z;\n    g1110 *= norm10.w;\n\n    vec4 norm11 = perlin_noise_4d_taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n    g0011 *= norm11.x;\n    g0111 *= norm11.y;\n    g1011 *= norm11.z;\n    g1111 *= norm11.w;\n\n    float n0000 = dot(g0000, Pf0);\n    float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n    float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n    float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n    float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n    float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n    float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n    float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n    float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n    float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n    float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n    float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n    float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n    float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n    float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n    float n1111 = dot(g1111, Pf1);\n\n    vec4 fade_xyzw = perlin_noise_4d_fade(Pf0);\n    vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n    vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n    vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n    vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n    float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n    return (2.2 * n_xyzw) / 2. + .5;\n}\n\nfloat fractal_perlin_noise_4d(vec4 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += perlin_noise_4d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec4 curl_perlin_noise_4d(vec4 p) {\n    const float DX = 0.01;\n\n    float v = perlin_noise_4d(p);\n    float x = perlin_noise_4d(p + vec4(DX, 0., 0., 0.));\n    float y = perlin_noise_4d(p + vec4(0., DX, 0., 0.));\n    float z = perlin_noise_4d(p + vec4(0., 0., DX, 0.));\n    float w = perlin_noise_4d(p + vec4(0., 0., 0., DX));\n    return normalize(vec4(v - x, v - y, v - x, v - w));\n}\n\nvec4 curl_fractal_perlin_noise_4d(vec4 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_perlin_noise_4d(p, iterations);\n    float x = fractal_perlin_noise_4d(p + vec4(DX, 0., 0., 0.), iterations);\n    float y = fractal_perlin_noise_4d(p + vec4(0., DX, 0., 0.), iterations);\n    float z = fractal_perlin_noise_4d(p + vec4(0., 0., DX, 0.), iterations);\n    float w = fractal_perlin_noise_4d(p + vec4(0., 0., 0., DX), iterations);\n    return normalize(vec4(v - x, v - y, v - x, v - w));\n}"},function(n,e,t){"use strict";t.r(e),e.default='[\n    "sdf",\n    "__raymarch__",\n    "surface"\n]'},function(n,e,t){"use strict";t.r(e),e.default="float sdf_sphere_basic(vec3 pos) {\n    return length(pos) - 1.;\n}\n\nfloat sdf_sphere(vec3 pos, vec3 center, float radius) {\n    return sdf_sphere_basic((pos - center) / radius) * radius;\n}\n\nfloat sdf_box_basic(vec3 pos, vec3 scale) {\n    vec3 q = abs(pos) - scale;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdf_box(vec3 pos, vec3 a, vec3 b) {\n    vec3 diff = abs(a - b);\n    vec3 avg = (a + b) / 2.;\n\n    return sdf_box_basic(pos - avg, diff);\n}\n\nfloat sdf_plane(vec3 pos, vec4 n) {\n    return dot(pos, n.xyz) + n.w;\n}\n\nfloat sdf_union(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sdf_smooth_union(float d1, float d2, float k) {\n    float h = clamp(0.5 + 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) - k * h * (1.0 - h);\n} \n\nfloat sdf_intersection(float d1, float d2) {\n    return max(d1, d2);\n}\n\nfloat sdf_smooth_intersection(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 - d1) / k, 0.0, 1.0);\n    return mix(d2, d1, h) + k * h * (1.0 - h);\n}\n\nfloat sdf_subtraction(float d1, float d2) {\n    return sdf_intersection(d1, -d2);\n}\n\nfloat sdf_smooth_subtraction(float d1, float d2, float k) {\n    float h = clamp(0.5 - 0.5 * (d2 + d1) / k, 0.0, 1.0);\n    return mix(d2, -d1, h) + k * h * (1.0 - h);\n}"},function(n,e,t){"use strict";t.r(e),e.default='[\n    "simplex_noise_2d",\n    "simplex_noise_3d",\n    "simplex_noise_4d"\n]'},function(n,e,t){"use strict";t.r(e),e.default="vec3 simplex_noise_2d_permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n\nfloat simplex_noise_2d(vec2 v) {\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = simplex_noise_2d_permute( simplex_noise_2d_permute( i.y + vec3(0.0, i1.y, 1.0 ))\n    + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return (130.0 * dot(m, g)) / 2. + .5;\n}\n\nfloat fractal_simplex_noise_2d(vec2 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += simplex_noise_2d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec2 curl_simplex_noise_2d(vec2 p) {\n    const float DX = 0.01;\n\n    float v = simplex_noise_2d(p);\n    float x = simplex_noise_2d(p + vec2(DX, 0.));\n    float y = simplex_noise_2d(p + vec2(0., DX));\n    return normalize(vec2(v - x, v - y));\n}\n\nvec2 curl_fractal_simplex_noise_2d(vec2 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_simplex_noise_2d(p, iterations);\n    float x = fractal_simplex_noise_2d(p + vec2(DX, 0.), iterations);\n    float y = fractal_simplex_noise_2d(p + vec2(0., DX), iterations);\n    return normalize(vec2(v - x, v - y));\n}"},function(n,e,t){"use strict";t.r(e),e.default="vec4 simplex_noise_3d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nvec4 simplex_noise_3d_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nfloat simplex_noise_3d(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    //  x0 = x0 - 0. + 0.0 * C \n    vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n    vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n    vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n    // Permutations\n    i = mod(i, 289.0 ); \n    vec4 p = simplex_noise_3d_permute( simplex_noise_3d_permute( simplex_noise_3d_permute( \n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients\n    // ( N*N points uniformly over a square, mapped onto an octahedron.)\n    float n_ = 1.0/7.0; // N=7\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = simplex_noise_3d_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return (42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) )) / 2. + .5;\n}\n\nfloat fractal_simplex_noise_3d(vec3 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += simplex_noise_3d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec3 curl_simplex_noise_3d(vec3 p) {\n    const float DX = 0.01;\n\n    float v = simplex_noise_3d(p);\n    float x = simplex_noise_3d(p + vec3(DX, 0., 0.));\n    float y = simplex_noise_3d(p + vec3(0., DX, 0.));\n    float z = simplex_noise_3d(p + vec3(0., 0., DX));\n    return normalize(vec3(v - x, v - y, v - x));\n}\n\nvec3 curl_fractal_simplex_noise_3d(vec3 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_simplex_noise_3d(p, iterations);\n    float x = fractal_simplex_noise_3d(p + vec3(DX, 0., 0.), iterations);\n    float y = fractal_simplex_noise_3d(p + vec3(0., DX, 0.), iterations);\n    float z = fractal_simplex_noise_3d(p + vec3(0., 0., DX), iterations);\n    return normalize(vec3(v - x, v - y, v - z));\n}"},function(n,e,t){"use strict";t.r(e),e.default="vec4 simplex_noise_4d_permute(vec4 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\nfloat simplex_noise_4d_permute(float x) { return floor(mod(((x*34.0)+1.0)*x, 289.0)); }\nvec4 simplex_noise_4d_taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }\nfloat simplex_noise_4d_taylorInvSqrt(float r) { return 1.79284291400159 - 0.85373472095314 * r; }\n\nvec4 simplex_noise_4d_grad(float j, vec4 ip) {\n    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n    vec4 p,s;\n\n    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n    s = vec4(lessThan(p, vec4(0.0)));\n    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n    return p;\n}\n\nfloat simplex_noise_4d(vec4 v) {\n    const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n    // First corner\n    vec4 i  = floor(v + dot(v, C.yyyy) );\n    vec4 x0 = v -   i + dot(i, C.xxxx);\n\n    // Other corners\n\n    // Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n    vec4 i0;\n\n    vec3 isX = step( x0.yzw, x0.xxx );\n    vec3 isYZ = step( x0.zww, x0.yyz );\n    //  i0.x = dot( isX, vec3( 1.0 ) );\n    i0.x = isX.x + isX.y + isX.z;\n    i0.yzw = 1.0 - isX;\n\n    //  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n    i0.y += isYZ.x + isYZ.y;\n    i0.zw += 1.0 - isYZ.xy;\n\n    i0.z += isYZ.z;\n    i0.w += 1.0 - isYZ.z;\n\n    // i0 now contains the unique values 0,1,2,3 in each channel\n    vec4 i3 = clamp( i0, 0.0, 1.0 );\n    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n    //  x0 = x0 - 0.0 + 0.0 * C \n    vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n    vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n    vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n    vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n    // Permutations\n    i = mod(i, 289.0); \n    float j0 = simplex_noise_4d_permute( simplex_noise_4d_permute( simplex_noise_4d_permute( simplex_noise_4d_permute(i.w) + i.z) + i.y) + i.x);\n    vec4 j1 = simplex_noise_4d_permute( simplex_noise_4d_permute( simplex_noise_4d_permute( simplex_noise_4d_permute (\n            i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n        + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n        + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n        + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n    // Gradients\n    // ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n    // 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n    vec4 p0 = simplex_noise_4d_grad(j0,   ip);\n    vec4 p1 = simplex_noise_4d_grad(j1.x, ip);\n    vec4 p2 = simplex_noise_4d_grad(j1.y, ip);\n    vec4 p3 = simplex_noise_4d_grad(j1.z, ip);\n    vec4 p4 = simplex_noise_4d_grad(j1.w, ip);\n\n    // Normalise gradients\n    vec4 norm = simplex_noise_4d_taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n    p4 *= simplex_noise_4d_taylorInvSqrt(dot(p4,p4));\n\n    // Mix contributions from the five corners\n    vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n    vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n    m0 = m0 * m0;\n    m1 = m1 * m1;\n    return (49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n            + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) )) / 2. + .5;\n\n}\n\nfloat fractal_simplex_noise_4d(vec4 p, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += simplex_noise_4d(p / scale) * scale;\n        divide += scale;\n        \n        scale *= .5;\n    }\n\n    return total / divide;\n}\n\nvec4 curl_simplex_noise_4d(vec4 p) {\n    const float DX = 0.01;\n\n    float v = simplex_noise_4d(p);\n    float x = simplex_noise_4d(p + vec4(DX, 0., 0., 0.));\n    float y = simplex_noise_4d(p + vec4(0., DX, 0., 0.));\n    float z = simplex_noise_4d(p + vec4(0., 0., DX, 0.));\n    float w = simplex_noise_4d(p + vec4(0., 0., 0., DX));\n    return normalize(vec4(v - x, v - y, v - x, v - w));\n}\n\nvec4 curl_fractal_simplex_noise_4d(vec4 p, int iterations) {\n    const float DX = 0.01;\n\n    float v = fractal_simplex_noise_4d(p, iterations);\n    float x = fractal_simplex_noise_4d(p + vec4(DX, 0., 0., 0.), iterations);\n    float y = fractal_simplex_noise_4d(p + vec4(0., DX, 0., 0.), iterations);\n    float z = fractal_simplex_noise_4d(p + vec4(0., 0., DX, 0.), iterations);\n    float w = fractal_simplex_noise_4d(p + vec4(0., 0., 0., DX), iterations);\n    return normalize(vec4(v - x, v - y, v - x, v - w));\n}"},function(n,e,t){"use strict";t.r(e),e.default="struct Surface {\n    int id;\n    float distance;\n\n    vec3 diffuse;\n    vec3 ambient;\n    vec3 specular;\n};\n\nSurface create_surface(int id) {\n    return Surface(id, 999999999., vec3(0., 0., 0.), vec3(0., 0., 0.), vec3(0., 0., 0.));\n}\n\nSurface compare_surfaces(Surface a, Surface b) {\n    if (a.distance < b.distance) {\n        return a;\n    }\n\n    return b;\n}\n\nvec3 surface_color(Surface surface, vec3 look, vec3 normal, vec3 lightDirection) {\n    look = normalize(look);\n    normal = normalize(normal);\n    lightDirection = normalize(lightDirection);\n\n    float cosTheta = clamp(dot(normal, lightDirection), 0., 1.);\n    vec3 reflection = reflect(-lightDirection, normal);\n    float cosAlpha = clamp(dot(look, reflection), 0., 1.);\n\n    vec3 finalColor = surface.ambient;\n    finalColor += surface.diffuse * cosTheta;\n    finalColor += surface.specular * pow(cosAlpha, 5.);\n\n    return finalColor;\n}"},function(n,e,t){"use strict";t.r(e),e.default='[\n    "voronoise_2d",\n    "voronoise_3d"\n]'},function(n,e,t){"use strict";t.r(e),e.default="float voronoise_2d_hash(vec2 p) {\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x))));\n}\n\nvec2 voronoise_2d_hash2d(vec2 p) {\n    return vec2(voronoise_2d_hash(p + vec2(0.5, 0)), voronoise_2d_hash(p + vec2(0, 0.5)));\n}\n\n// From https://www.iquilezles.org/www/articles/voronoise/voronoise.htm\nfloat voronoise_2d(vec2 p, float u, float v) {\n    vec2 p_floor = floor(p);\n    vec2 f = fract(p);\n\n    float k = 1.0 - v;\n    k = k * k;\n    k = k * k;\n    k = 1.0 + 63.0 * k;\n    float va = 0.0;\n    float wt = 0.0;\n\n    for (int x = -2; x <= 2; x++) {\n        for (int y = -2; y <= 2; y++) {\n            vec2 g = vec2(x, y);\n            float value = voronoise_2d_hash(p_floor + g);\n            vec2 o = voronoise_2d_hash2d(p_floor + g) * u;\n            vec2 r = g - f + o;\n            float d = dot(r, r);\n            float w = pow(1. - smoothstep(0.0, 2., sqrt(d)), k);\n            va += w * value;\n            wt += w;\n        }\n    }\n\n    return va / wt;\n}\n\nfloat fractal_voronoise_2d(vec2 p, float u, float v, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n    float invScale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += voronoise_2d(p * invScale, u, v) * scale;\n        divide += scale;\n        \n        scale *= .4;\n        invScale *= 2.5;\n    }\n\n    return total / divide;\n}\n\nvec2 curl_voronoise_2d(vec2 p, float u, float v) {\n    const float DX = 0.01;\n\n    float val = voronoise_2d(p, u, v);\n    float x = voronoise_2d(p + vec2(DX, 0.), u, v);\n    float y = voronoise_2d(p + vec2(0., DX), u, v);\n    return normalize(vec2(val - x, val - y));\n}\n\nvec2 curl_fractal_voronoise_2d(vec2 p, float u, float v, int iterations) {\n    const float DX = 0.01;\n\n    float val = fractal_voronoise_2d(p, u, v, iterations);\n    float x = fractal_voronoise_2d(p + vec2(DX, 0.), u, v, iterations);\n    float y = fractal_voronoise_2d(p + vec2(0., DX), u, v, iterations);\n    return normalize(vec2(val - x, val - y));\n}"},function(n,e,t){"use strict";t.r(e),e.default="float voronoise_3d_hash(vec3 p) {\n    return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x - p.z)) * sin(12.0 * p.z - sin(p.x * 10.0))));\n}\n\nvec3 voronoise_3d_hash3d(vec3 p) {\n    return vec3(voronoise_3d_hash(p + vec3(0.5, 0, 0)), voronoise_3d_hash(p + vec3(0, 0.5, 0)), voronoise_3d_hash(p + vec3(0, 0, 0.5)));\n}\n\n// From https://www.iquilezles.org/www/articles/voronoise/voronoise.htm and https://www.shadertoy.com/view/4ljGzW\nfloat voronoise_3d(vec3 p, float u, float v) {\n    vec3 p_floor = floor(p);\n    vec3 f = fract(p);\n\n    float k = 1.0 - v;\n    k = k * k;\n    k = k * k;\n    k = 1.0 + 31.0 * k;\n    float va = 0.0;\n    float wt = 0.0;\n\n    for (int x = -2; x <= 2; x++) {\n        for (int y = -2; y <= 2; y++) {\n            for (int z = -2; z <= 2; z++) {\n                vec3 g = vec3(x, y, z);\n                float value = voronoise_3d_hash(p_floor + g);\n                vec3 o = voronoise_3d_hash3d(p_floor + g) * u;\n                vec3 r = g - f + o;\n                float d = dot(r, r);\n                float w = pow(1. - smoothstep(0.0, 2., sqrt(d)), k);\n                va += w * value;\n                wt += w;\n            }\n        }\n    }\n\n    return va / wt;\n}\n\nfloat fractal_voronoise_3d(vec3 p, float u, float v, int iterations) {\n    float total = 0.;\n    float divide = 0.;\n\n    float scale = 1.;\n    float invScale = 1.;\n\n    for (int iter = 0; iter < 10; iter++) {\n        if (iter >= iterations) {\n            break;\n        }\n        \n        total += voronoise_3d(p * invScale, u, v) * scale;\n        divide += scale;\n        \n        scale *= .4;\n        invScale *= 2.5;\n    }\n\n    return total / divide;\n}\n\nvec3 curl_voronoise_3d(vec3 p, float u, float v) {\n    const float DX = 0.01;\n\n    float val = voronoise_3d(p, u, v);\n    float x = voronoise_3d(p + vec3(DX, 0., 0.), u, v);\n    float y = voronoise_3d(p + vec3(0., DX, 0.), u, v);\n    float z = voronoise_3d(p + vec3(0., 0., DX), u, v);\n    return normalize(vec3(val - x, val - y, val - z));\n}\n\nvec3 curl_fractal_voronoise_3d(vec3 p, float u, float v, int iterations) {\n    const float DX = 0.01;\n\n    float val = fractal_voronoise_3d(p, u, v, iterations);\n    float x = fractal_voronoise_3d(p + vec3(DX, 0., 0.), u, v, iterations);\n    float y = fractal_voronoise_3d(p + vec3(0., DX, 0.), u, v, iterations);\n    float z = fractal_voronoise_3d(p + vec3(0., 0., DX), u, v, iterations);\n    return normalize(vec3(val - x, val - y, val - z));\n}\n"},function(n,e,t){var o=function(n){"use strict";var e=Object.prototype,t=e.hasOwnProperty,o="function"==typeof Symbol?Symbol:{},r=o.iterator||"@@iterator",i=o.asyncIterator||"@@asyncIterator",a=o.toStringTag||"@@toStringTag";function c(n,e,t){return Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}),n[e]}try{c({},"")}catch(n){c=function(n,e,t){return n[e]=t}}function l(n,e,t,o){var r=e&&e.prototype instanceof v?e:v,i=Object.create(r.prototype),a=new z(o||[]);return i._invoke=function(n,e,t){var o="suspendedStart";return function(r,i){if("executing"===o)throw new Error("Generator is already running");if("completed"===o){if("throw"===r)throw i;return S()}for(t.method=r,t.arg=i;;){var a=t.delegate;if(a){var c=m(a,t);if(c){if(c===f)continue;return c}}if("next"===t.method)t.sent=t._sent=t.arg;else if("throw"===t.method){if("suspendedStart"===o)throw o="completed",t.arg;t.dispatchException(t.arg)}else"return"===t.method&&t.abrupt("return",t.arg);o="executing";var l=s(n,e,t);if("normal"===l.type){if(o=t.done?"completed":"suspendedYield",l.arg===f)continue;return{value:l.arg,done:t.done}}"throw"===l.type&&(o="completed",t.method="throw",t.arg=l.arg)}}}(n,t,a),i}function s(n,e,t){try{return{type:"normal",arg:n.call(e,t)}}catch(n){return{type:"throw",arg:n}}}n.wrap=l;var f={};function v(){}function u(){}function _(){}var d={};d[r]=function(){return this};var p=Object.getPrototypeOf,h=p&&p(p(P([])));h&&h!==e&&t.call(h,r)&&(d=h);var y=_.prototype=v.prototype=Object.create(d);function x(n){["next","throw","return"].forEach((function(e){c(n,e,(function(n){return this._invoke(e,n)}))}))}function g(n,e){var o;this._invoke=function(r,i){function a(){return new e((function(o,a){!function o(r,i,a,c){var l=s(n[r],n,i);if("throw"!==l.type){var f=l.arg,v=f.value;return v&&"object"==typeof v&&t.call(v,"__await")?e.resolve(v.__await).then((function(n){o("next",n,a,c)}),(function(n){o("throw",n,a,c)})):e.resolve(v).then((function(n){f.value=n,a(f)}),(function(n){return o("throw",n,a,c)}))}c(l.arg)}(r,i,o,a)}))}return o=o?o.then(a,a):a()}}function m(n,e){var t=n.iterator[e.method];if(void 0===t){if(e.delegate=null,"throw"===e.method){if(n.iterator.return&&(e.method="return",e.arg=void 0,m(n,e),"throw"===e.method))return f;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return f}var o=s(t,n.iterator,e.arg);if("throw"===o.type)return e.method="throw",e.arg=o.arg,e.delegate=null,f;var r=o.arg;return r?r.done?(e[n.resultName]=r.value,e.next=n.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0),e.delegate=null,f):r:(e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,f)}function b(n){var e={tryLoc:n[0]};1 in n&&(e.catchLoc=n[1]),2 in n&&(e.finallyLoc=n[2],e.afterLoc=n[3]),this.tryEntries.push(e)}function w(n){var e=n.completion||{};e.type="normal",delete e.arg,n.completion=e}function z(n){this.tryEntries=[{tryLoc:"root"}],n.forEach(b,this),this.reset(!0)}function P(n){if(n){var e=n[r];if(e)return e.call(n);if("function"==typeof n.next)return n;if(!isNaN(n.length)){var o=-1,i=function e(){for(;++o<n.length;)if(t.call(n,o))return e.value=n[o],e.done=!1,e;return e.value=void 0,e.done=!0,e};return i.next=i}}return{next:S}}function S(){return{value:void 0,done:!0}}return u.prototype=y.constructor=_,_.constructor=u,u.displayName=c(_,a,"GeneratorFunction"),n.isGeneratorFunction=function(n){var e="function"==typeof n&&n.constructor;return!!e&&(e===u||"GeneratorFunction"===(e.displayName||e.name))},n.mark=function(n){return Object.setPrototypeOf?Object.setPrototypeOf(n,_):(n.__proto__=_,c(n,a,"GeneratorFunction")),n.prototype=Object.create(y),n},n.awrap=function(n){return{__await:n}},x(g.prototype),g.prototype[i]=function(){return this},n.AsyncIterator=g,n.async=function(e,t,o,r,i){void 0===i&&(i=Promise);var a=new g(l(e,t,o,r),i);return n.isGeneratorFunction(t)?a:a.next().then((function(n){return n.done?n.value:a.next()}))},x(y),c(y,a,"Generator"),y[r]=function(){return this},y.toString=function(){return"[object Generator]"},n.keys=function(n){var e=[];for(var t in n)e.push(t);return e.reverse(),function t(){for(;e.length;){var o=e.pop();if(o in n)return t.value=o,t.done=!1,t}return t.done=!0,t}},n.values=P,z.prototype={constructor:z,reset:function(n){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(w),!n)for(var e in this)"t"===e.charAt(0)&&t.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function(){this.done=!0;var n=this.tryEntries[0].completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(n){if(this.done)throw n;var e=this;function o(t,o){return a.type="throw",a.arg=n,e.next=t,o&&(e.method="next",e.arg=void 0),!!o}for(var r=this.tryEntries.length-1;r>=0;--r){var i=this.tryEntries[r],a=i.completion;if("root"===i.tryLoc)return o("end");if(i.tryLoc<=this.prev){var c=t.call(i,"catchLoc"),l=t.call(i,"finallyLoc");if(c&&l){if(this.prev<i.catchLoc)return o(i.catchLoc,!0);if(this.prev<i.finallyLoc)return o(i.finallyLoc)}else if(c){if(this.prev<i.catchLoc)return o(i.catchLoc,!0)}else{if(!l)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return o(i.finallyLoc)}}}},abrupt:function(n,e){for(var o=this.tryEntries.length-1;o>=0;--o){var r=this.tryEntries[o];if(r.tryLoc<=this.prev&&t.call(r,"finallyLoc")&&this.prev<r.finallyLoc){var i=r;break}}i&&("break"===n||"continue"===n)&&i.tryLoc<=e&&e<=i.finallyLoc&&(i=null);var a=i?i.completion:{};return a.type=n,a.arg=e,i?(this.method="next",this.next=i.finallyLoc,f):this.complete(a)},complete:function(n,e){if("throw"===n.type)throw n.arg;return"break"===n.type||"continue"===n.type?this.next=n.arg:"return"===n.type?(this.rval=this.arg=n.arg,this.method="return",this.next="end"):"normal"===n.type&&e&&(this.next=e),f},finish:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.finallyLoc===n)return this.complete(t.completion,t.afterLoc),w(t),f}},catch:function(n){for(var e=this.tryEntries.length-1;e>=0;--e){var t=this.tryEntries[e];if(t.tryLoc===n){var o=t.completion;if("throw"===o.type){var r=o.arg;w(t)}return r}}throw new Error("illegal catch attempt")},delegateYield:function(n,e,t){return this.delegate={iterator:P(n),resultName:e,nextLoc:t},"next"===this.method&&(this.arg=void 0),f}},n}(n.exports);try{regeneratorRuntime=o}catch(n){Function("r","regeneratorRuntime = r")(o)}},function(n,e,t){var o={"./__global__.fsh":0,"./__raymarch__.fsh":1,"./camera.fsh":2,"./clover_noise":3,"./clover_noise_2d.fsh":4,"./clover_noise_3d.fsh":5,"./color.fsh":6,"./noise":7,"./perlin_noise":8,"./perlin_noise_2d.fsh":9,"./perlin_noise_3d.fsh":10,"./perlin_noise_4d.fsh":11,"./raymarch":12,"./sdf.fsh":13,"./simplex_noise":14,"./simplex_noise_2d.fsh":15,"./simplex_noise_3d.fsh":16,"./simplex_noise_4d.fsh":17,"./surface.fsh":18,"./voronoise":19,"./voronoise_2d.fsh":20,"./voronoise_3d.fsh":21};function r(n){var e=i(n);return t(e)}function i(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}r.keys=function(){return Object.keys(o)},r.resolve=i,n.exports=r,r.id=23},function(n,e,t){var o={"./__global__.fsh":0,"./__raymarch__.fsh":1,"./camera.fsh":2,"./clover_noise":3,"./clover_noise_2d.fsh":4,"./clover_noise_3d.fsh":5,"./color.fsh":6,"./noise":7,"./perlin_noise":8,"./perlin_noise_2d.fsh":9,"./perlin_noise_3d.fsh":10,"./perlin_noise_4d.fsh":11,"./raymarch":12,"./sdf.fsh":13,"./simplex_noise":14,"./simplex_noise_2d.fsh":15,"./simplex_noise_3d.fsh":16,"./simplex_noise_4d.fsh":17,"./surface.fsh":18,"./voronoise":19,"./voronoise_2d.fsh":20,"./voronoise_3d.fsh":21};function r(n){var e=i(n);return t(e)}function i(n){if(!t.o(o,n)){var e=new Error("Cannot find module '"+n+"'");throw e.code="MODULE_NOT_FOUND",e}return o[n]}r.keys=function(){return Object.keys(o)},r.resolve=i,n.exports=r,r.id=24},function(n,e,t){"use strict";t.r(e);t(22);function o(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return r(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return r(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,i=function(){};return{s:i,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var a,c=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return c=n.done,n},e:function(n){l=!0,a=n},f:function(){try{c||null==t.return||t.return()}finally{if(l)throw a}}}}function r(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}var i={initShaderProgram:function(n,e,t){var o=i.loadShader(n,n.VERTEX_SHADER,e),r=i.loadShader(n,n.FRAGMENT_SHADER,t);if(null==o||null==r)return null;var a=n.createProgram();return n.attachShader(a,o),n.attachShader(a,r),n.linkProgram(a),n.getProgramParameter(a,n.LINK_STATUS)?a:(console.groupCollapsed("Shader Sketch Program Link Error"),console.error(n.getProgramInfoLog(a)),console.groupEnd(),null)},loadShader:function(n,e,t){var o=n.createShader(e);return n.shaderSource(o,t),n.compileShader(o),n.getShaderParameter(o,n.COMPILE_STATUS)?o:(console.groupCollapsed("Shader Sketch Shader Compilation Error"),console.error(n.getShaderInfoLog(o)),console.groupCollapsed("Shader Source..."),console.log(t),console.groupEnd(),console.groupEnd(),n.deleteShader(o),null)},removeAll:function(n,e){var t=n;return e.forEach((function(n){return t=t.split(n).join("")})),t},parseUniformValues:function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];return"string"==typeof e[0]&&(e[0]=i.removeAll(e[0],[" ","[","]"]),e=e[0].split(",").map(parseFloat)),e[0]instanceof Array&&(e=e[0]),e},textWrap:function(n,e,t){if(t==1/0)return{lines:[e],width:n.measureText(e).width};var r,i=[""],a=0,c=o(e.split(" "));try{for(c.s();!(r=c.n()).done;){var l=r.value,s="".concat(i[i.length-1]," ").concat(l).trim(),f=n.measureText(s).width;f>t&&""!=i[i.length-1]?(i.push(l),(f=n.measureText(l).width)>a&&(a=f)):(f>a&&(a=f),i[i.length-1]=s)}}catch(n){c.e(n)}finally{c.f()}return{lines:i,width:a}},determineFontHeight:function(n){var e=document.getElementsByTagName("body")[0],t=document.createElement("div"),o=document.createTextNode("M");t.appendChild(o),t.setAttribute("style",n),e.appendChild(t);var r=t.offsetHeight;return e.removeChild(t),r},generateTypographyCanvas:function(n){var e=n.text,t=n.fontSize,r=n.fontFamily,a=n.fontStyle,c=n.fontWeight,l=n.textWrap,s=n.textAlign,f=n.margin,v=document.createElement("canvas"),u=v.getContext("2d"),_="".concat(a," ").concat(c," ").concat(t,"px ").concat(r);u.textAlign=s,u.font=_;var d=i.textWrap(u,e,l),p=d.lines,h=d.width,y=i.determineFontHeight("font: ".concat(_,";")),x=y*p.length;v.width=h+2*f,v.height=x+2*f,u.font=_,u.textBaseline="top",u.fillStyle="black",u.fillRect(0,0,v.width,v.height),u.fillStyle="white",u.translate(0,v.height),u.scale(1,-1);var g,m=f,b=o(p);try{for(b.s();!(g=b.n()).done;){var w=g.value;u.fillText(w,f,m),m+=y}}catch(n){b.e(n)}finally{b.f()}return v}},a=i;function c(n){return function(n){if(Array.isArray(n))return l(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||function(n,e){if(!n)return;if("string"==typeof n)return l(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return l(n,e)}(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function l(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function s(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function f(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}var v={int:{length:1,int:!0,setter:"1i",aliases:["int","i","int1","i1","1int","1i"]},float:{length:1,int:!1,setter:"1f",aliases:["float","f","float1","f1","1float","1f"]},ivec2:{length:2,int:!0,setter:"2i",aliases:["int2","i2","2int","2i","vec2i","ivec2"]},vec2:{length:2,int:!1,setter:"2f",aliases:["float2","f2","2float","2f","vec2"]},ivec3:{length:3,int:!0,setter:"3i",aliases:["int3","i3","3int","3i","vec3i","ivec3"]},vec3:{length:3,int:!1,setter:"3f",aliases:["float3","f3","3float","3f","vec3"]},ivec4:{length:4,int:!0,setter:"4i",aliases:["int4","i4","4int","4i","vec4i","ivec4"]},vec4:{length:4,int:!1,setter:"4f",aliases:["float4","f4","4float","4f","vec4"]}},u=function(){function n(e,t){s(this,n),this.name=e,t=n.getType(t),this.type=t.type,this.arrayLength=t.arrayLength;for(var o=arguments.length,r=new Array(o>2?o-2:0),i=2;i<o;i++)r[i-2]=arguments[i];this.setValue.apply(this,r)}var e,t,o;return e=n,o=[{key:"getType",value:function(n){var e="unknown",t=-1,o=n.split("[");for(var r in o.length>1&&(o[1]=parseInt(o[1].replace("]","")),t=o[1]),v)v[r].aliases.indexOf(o[0])>-1&&(e=r);return{type:e,arrayLength:t}}},{key:"getValue",value:function(n,e){for(var t=arguments.length,o=new Array(t>2?t-2:0),r=2;r<t;r++)o[r-2]=arguments[r];for(var i=a.parseUniformValues.apply(a,o),c=v[n].length*(e>-1?e:1);i.length<c;)i.push(0);return i=i.slice(0,c),v[n].int&&(i=i.map(Math.floor)),e>-1&&(i=[i]),i}}],(t=[{key:"setValue",value:function(){for(var e=arguments.length,t=new Array(e),o=0;o<e;o++)t[o]=arguments[o];this.value=n.getValue.apply(n,[this.type,this.arrayLength].concat(t))}},{key:"getUniformDeclaration",value:function(){return"uniform ".concat(this.type," ").concat(this.name).concat(this.arrayLength>-1?"[".concat(this.arrayLength,"]"):"",";")}},{key:"loadUniformLocation",value:function(n,e){this.location=n.getUniformLocation(e,this.name)}},{key:"setUniformValue",value:function(n){n["uniform".concat(v[this.type].setter).concat(this.arrayLength>-1?"v":"")].apply(n,[this.location].concat(c(this.value)))}}])&&f(e.prototype,t),o&&f(e,o),n}();function _(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function d(n){return function(n){if(Array.isArray(n))return y(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||h(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function p(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=h(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){c=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(c)throw i}}}}function h(n,e){if(n){if("string"==typeof n)return y(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?y(n,e):void 0}}function y(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}var x={};var g,m=function(){function n(e,t){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.name=e,this.code=t}var e,t,o;return e=n,o=[{key:"registerImport",value:function(e,t){x[e]=new n(e,t)}},{key:"getImport",value:function(n){return x[n]}},{key:"resolveImports",value:function(e){if(e.code instanceof Array){var t,o=[],r=p(e.code);try{for(r.s();!(t=r.n()).done;){var i=t.value;o.push.apply(o,d(n.resolveImports(n.getImport(i))))}}catch(n){r.e(n)}finally{r.f()}return o}return[e]}},{key:"resolveCode",value:function(e){e=function n(e){var t,o=[],r=p(e);try{for(r.s();!(t=r.n()).done;){var i=t.value;i instanceof Array?o.push.apply(o,d(n(i))):o.push(i)}}catch(n){r.e(n)}finally{r.f()}return o}(e.map((function(e){return n.resolveImports(e)})));var t,o=[],r=p(e);try{for(r.s();!(t=r.n()).done;){var i=t.value;-1==o.indexOf(i)&&o.push(i)}}catch(n){r.e(n)}finally{r.f()}return o.map((function(n){return n.getCode()})).join("\n")}}],(t=[{key:"getCode",value:function(){return"// --------------------\n// Import: ".concat(this.name,"\n// --------------------\n\n").concat(this.code,"\n")}}])&&_(e.prototype,t),o&&_(e,o),n}(),b=p(t(23).keys());try{for(b.s();!(g=b.n()).done;){var w=g.value,z=t(24)("./".concat(w.substring(2))).default;w.endsWith(".fsh")||(z=JSON.parse(z)),w=w.replace("./","").replace(".fsh",""),x[w]=new m(w,z)}}catch(n){b.e(n)}finally{b.f()}var P=m;function S(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function E(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}var k=function(){function n(e,t){var o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=o.blending,i=void 0===r?"linear":r,a=o.wrapping,c=void 0===a?"clamp":a,l=o.update,s=void 0!==l&&l;S(this,n),this.name=e,this.image=t,this.image instanceof rn&&(this.image=this.image.shaderSketch.buffer),this.blending=i||"linear",this.wrapping=c||"clamp",this.shouldUpdate=s||!1,this.resolutionUniform=new u("".concat(this.name,"_resolution"),"vec2",this.image.width,this.image.height),this.uniforms=[this.resolutionUniform]}var e,t,o;return e=n,(t=[{key:"update",value:function(n){this.resolutionUniform.setValue(this.image.width,this.image.height),this.shouldUpdate&&this.bindTexture(n)}},{key:"getUniformDeclaration",value:function(){return"uniform sampler2D ".concat(this.name,";")}},{key:"loadUniformLocation",value:function(n,e){this.location=n.getUniformLocation(e,this.name)}},{key:"bindTexture",value:function(n){this.unbindTexture(n),this.texture=n.createTexture();var e,t,o=n.RGBA,r=n.RGBA,i=n.UNSIGNED_BYTE;switch(n.bindTexture(n.TEXTURE_2D,this.texture),n.texImage2D(n.TEXTURE_2D,0,o,r,i,this.image),this.blending.toLowerCase()){case"linear":e=n.LINEAR;break;case"nearest":e=n.NEAREST}switch(this.wrapping.toLowerCase()){case"repeat":t=n.REPEAT;break;case"clamp":t=n.CLAMP_TO_EDGE;break;case"mirror":t=n.MIRRORED_REPEAT}n.texParameteri(n.TEXTURE_2D,n.TEXTURE_MIN_FILTER,e),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_S,t),n.texParameteri(n.TEXTURE_2D,n.TEXTURE_WRAP_T,t)}},{key:"unbindTexture",value:function(n){this.texture&&n.deleteTexture(this.texture)}}])&&E(e.prototype,t),o&&E(e,o),n}();function T(n,e,t){return(T=D()?Reflect.construct:function(n,e,t){var o=[null];o.push.apply(o,e);var r=new(Function.bind.apply(n,o));return t&&A(r,t.prototype),r}).apply(null,arguments)}function D(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function A(n,e){return(A=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function C(n){return function(n){if(Array.isArray(n))return X(n)}(n)||function(n){if("undefined"!=typeof Symbol&&null!=n[Symbol.iterator]||null!=n["@@iterator"])return Array.from(n)}(n)||R(n)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function O(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=R(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){c=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(c)throw i}}}}function R(n,e){if(n){if("string"==typeof n)return X(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?X(n,e):void 0}}function X(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function I(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}var j=["TEXTURE0","TEXTURE1","TEXTURE2","TEXTURE3","TEXTURE4","TEXTURE5","TEXTURE6","TEXTURE7"],U=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.element=e,this.buffer=document.createElement("canvas"),this.buffer.style.display="none",this.bufferCtx=this.buffer.getContext("2d"),this.gl=e.canvasElt.getContext("webgl",{preserveDrawingBuffer:!0}),this.uniforms=[],this.textures=[],this.imports=["__global__"],this.program=null,this.shouldCompileProgram=!0,this.positionBuffer=this.gl.createBuffer(),this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.bufferData(this.gl.ARRAY_BUFFER,new Float32Array([-1,-1,-1,1,1,-1,-1,1,1,-1,1,1]),this.gl.STATIC_DRAW),this.addUniform("viewportSize","vec2",0,0),this.frameCount=0,this.addUniform("frameCount","int",0),this.startTime=new Date,this.addUniform("timeElapsed","float",0),this.addUniform("mousePosition","vec2",0,0),this.addUniform("mouseState","int",0)}var e,t,o;return e=n,(t=[{key:"getExtraFragmentCode",value:function(){var n,e="precision highp float;",t=O(this.getUniforms());try{for(t.s();!(n=t.n()).done;){var o=n.value;e+="\n".concat(o.getUniformDeclaration())}}catch(n){t.e(n)}finally{t.f()}var r,i=O(this.textures);try{for(i.s();!(r=i.n()).done;){var a=r.value;e+="\n".concat(a.getUniformDeclaration())}}catch(n){i.e(n)}finally{i.f()}return e+="\n"+P.resolveCode(this.imports.map((function(n){return P.getImport(n)})))}},{key:"compileProgram",value:function(){this.shouldCompileProgram=!1;var n="void main() {\n\tgl_FragColor = vec4(gl_FragCoord.xy / viewportSize, 0., 1.);\n}";if(null!=this.element.fragmentShaderElt&&(n=this.element.fragmentShaderElt.textContent),n=this.getExtraFragmentCode()+"\n"+n,this.program=a.initShaderProgram(this.gl,"attribute vec4 position;\n\nvoid main() {\n\tgl_Position = position;\n}",n),null!=this.program){var e,t=O(this.getUniforms());try{for(t.s();!(e=t.n()).done;)e.value.loadUniformLocation(this.gl,this.program)}catch(n){t.e(n)}finally{t.f()}var o,r=O(this.textures);try{for(r.s();!(o=r.n()).done;)o.value.loadUniformLocation(this.gl,this.program)}catch(n){r.e(n)}finally{r.f()}}}},{key:"canRender",value:function(){return null!=this.program}},{key:"render",value:function(){if(this.shouldCompileProgram&&this.compileProgram(),this.canRender()){this.bufferCtx.clearRect(0,0,this.buffer.width,this.buffer.height),this.bufferCtx.drawImage(this.element.canvasElt,0,0),this.frameCount++,this.setUniform("frameCount",this.frameCount),this.setUniform("timeElapsed",(new Date-this.startTime)/1e3),this.gl.useProgram(this.program),this.bindTextures();var n,e=O(this.getUniforms());try{for(e.s();!(n=e.n()).done;)n.value.setUniformValue(this.gl)}catch(n){e.e(n)}finally{e.f()}this.gl.clearColor(0,0,0,1),this.gl.clear(this.gl.COLOR_BUFFER_BIT);var t=this.gl.FLOAT,o=this.gl.getAttribLocation(this.program,"position");this.gl.bindBuffer(this.gl.ARRAY_BUFFER,this.positionBuffer),this.gl.vertexAttribPointer(o,2,t,!1,0,0),this.gl.enableVertexAttribArray(o),this.gl.drawArrays(this.gl.TRIANGLES,0,6)}}},{key:"bindTextures",value:function(){var n,e=0,t=O(this.textures);try{for(t.s();!(n=t.n()).done;){var o=n.value;if(e>=j.length)break;var r=this.gl[j[e]];this.gl.activeTexture(r),o.update(this.gl),this.gl.bindTexture(this.gl.TEXTURE_2D,o.texture),this.gl.uniform1i(o.location,e),e++}}catch(n){t.e(n)}finally{t.f()}}},{key:"getUniforms",value:function(){var n,e=this.uniforms,t=O(this.textures);try{for(t.s();!(n=t.n()).done;){var o=n.value;e=[].concat(C(e),C(o.uniforms))}}catch(n){t.e(n)}finally{t.f()}return e}},{key:"addUniform",value:function(n,e){for(var t=arguments.length,o=new Array(t>2?t-2:0),r=2;r<t;r++)o[r-2]=arguments[r];this.uniforms.push(T(u,[n,e].concat(o))),this.shouldCompileProgram=!0}},{key:"getUniform",value:function(n){var e,t=O(this.getUniforms());try{for(t.s();!(e=t.n()).done;){var o=e.value;if(o.name==n)return o}}catch(n){t.e(n)}finally{t.f()}return null}},{key:"setUniform",value:function(n){var e=this.getUniform(n);if(null!=e){for(var t=arguments.length,o=new Array(t>1?t-1:0),r=1;r<t;r++)o[r-1]=arguments[r];e.setValue.apply(e,o)}}},{key:"addTexture",value:function(){for(var n=arguments.length,e=new Array(n),t=0;t<n;t++)e[t]=arguments[t];var o=T(k,e);o.bindTexture(this.gl),this.textures.push(o)}},{key:"getTexture",value:function(n){var e,t=O(this.textures);try{for(t.s();!(e=t.n()).done;){var o=e.value;if(o.name==n)return o}}catch(n){t.e(n)}finally{t.f()}return null}},{key:"deleteTexture",value:function(n){var e=this.getTexture(n);null!=e&&(e.unbindTexture(this.gl),this.textures.splice(this.textures.indexOf(e),1))}}])&&I(e.prototype,t),o&&I(e,o),n}();function L(n){return(L="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function M(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function F(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function N(n,e){return!e||"object"!==L(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function B(n){var e="function"==typeof Map?new Map:void 0;return(B=function(n){if(null===n||(t=n,-1===Function.toString.call(t).indexOf("[native code]")))return n;var t;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(n))return e.get(n);e.set(n,o)}function o(){return q(n,arguments,H(this).constructor)}return o.prototype=Object.create(n.prototype,{constructor:{value:o,enumerable:!1,writable:!0,configurable:!0}}),V(o,n)})(n)}function q(n,e,t){return(q=G()?Reflect.construct:function(n,e,t){var o=[null];o.push.apply(o,e);var r=new(Function.bind.apply(n,o));return t&&V(r,t.prototype),r}).apply(null,arguments)}function G(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function V(n,e){return(V=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function H(n){return(H=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var Y=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&V(n,e)}(c,n);var e,t,o,r,i,a=(e=c,t=G(),function(){var n,o=H(e);if(t){var r=H(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return N(this,n)});function c(){return M(this,c),a.apply(this,arguments)}return o=c,(r=[{key:"connectedCallback",value:function(){this.update(this.parentNode)}},{key:"update",value:function(n){n instanceof rn&&(this.parent=n,this.parent.updateChild({child:this,add:!0}))}},{key:"disconnectedCallback",value:function(){this.parent instanceof rn&&(this.parent.updateChild({child:this,add:!1}),this.parent=null)}}])&&F(o.prototype,r),i&&F(o,i),c}(B(HTMLElement));function W(n){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function K(n,e){var t="undefined"!=typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=function(n,e){if(!n)return;if("string"==typeof n)return Z(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);"Object"===t&&n.constructor&&(t=n.constructor.name);if("Map"===t||"Set"===t)return Array.from(n);if("Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))return Z(n,e)}(n))||e&&n&&"number"==typeof n.length){t&&(n=t);var o=0,r=function(){};return{s:r,n:function(){return o>=n.length?{done:!0}:{done:!1,value:n[o++]}},e:function(n){throw n},f:r}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var i,a=!0,c=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){c=!0,i=n},f:function(){try{a||null==t.return||t.return()}finally{if(c)throw i}}}}function Z(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,o=new Array(e);t<e;t++)o[t]=n[t];return o}function $(n,e){for(var t=0;t<e.length;t++){var o=e[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(n,o.key,o)}}function J(n,e){return!e||"object"!==W(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function Q(n){var e="function"==typeof Map?new Map:void 0;return(Q=function(n){if(null===n||(t=n,-1===Function.toString.call(t).indexOf("[native code]")))return n;var t;if("function"!=typeof n)throw new TypeError("Super expression must either be null or a function");if(void 0!==e){if(e.has(n))return e.get(n);e.set(n,o)}function o(){return nn(n,arguments,on(this).constructor)}return o.prototype=Object.create(n.prototype,{constructor:{value:o,enumerable:!1,writable:!0,configurable:!0}}),tn(o,n)})(n)}function nn(n,e,t){return(nn=en()?Reflect.construct:function(n,e,t){var o=[null];o.push.apply(o,e);var r=new(Function.bind.apply(n,o));return t&&tn(r,t.prototype),r}).apply(null,arguments)}function en(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}function tn(n,e){return(tn=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function on(n){return(on=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}var rn=function(n){!function(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&tn(n,e)}(l,n);var e,t,o,r,i,c=(e=l,t=en(),function(){var n,o=on(e);if(t){var r=on(this).constructor;n=Reflect.construct(o,arguments,r)}else n=o.apply(this,arguments);return J(this,n)});function l(){var n;return function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,l),(n=c.call(this)).shadow=n.attachShadow({mode:"open"}),n.styleElt=document.createElement("style"),n.styleElt.textContent=":host {\n\tposition: relative;\n\tdisplay: inline-block;\n\twidth: 250px;\n\theight: 250px;\n}\n\n:host > canvas {\n\tposition: absolute;\n\ttop: 0;\n\tleft: 0;\n}",n.canvasElt=document.createElement("canvas"),n.shadow.appendChild(n.styleElt),n.shadow.appendChild(n.canvasElt),n.mounted=!1,n.loadingTextures=[],n.fragmentShaderElt=null,n}return o=l,(r=[{key:"getMousePosition",value:function(n){return[n.x-this.rect.x,this.height-n.y+this.rect.y]}},{key:"connectedCallback",value:function(){var n=this;this.mounted=!0,this.shaderSketch=new U(this),this.shadow.appendChild(this.shaderSketch.buffer),this.onmousedown=function(e){n.setUniform("mousePosition",n.getMousePosition(e)),n.setUniform("mouseState",1)},this.onmousemove=function(e){n.setUniform("mousePosition",n.getMousePosition(e))},this.onmouseup=function(e){n.setUniform("mousePosition",n.getMousePosition(e)),n.setUniform("mouseState",0)};var e,t=K(this.childNodes);try{for(t.s();!(e=t.n()).done;){var o=e.value;o instanceof Y&&o.update(this)}}catch(n){t.e(n)}finally{t.f()}this.render()}},{key:"disconnectedCallback",value:function(){this.mounted=!1,this.shadow.removeChild(this.shaderSketch.buffer),this.shaderSketch=null,this.onmousedown=null,this.onmousemove=null,this.onmouseup=null}},{key:"updateChild",value:function(n){var e=this,t=n.child,o=n.add;switch(t.tagName.toLowerCase()){case"fragment-shader":this.fragmentShaderElt=o?t:null;break;case"shader-uniform":if(!o)break;var r=t.getAttribute("name"),i=t.getAttribute("type"),c=t.getAttribute("value");null==this.getUniform(r)?this.addUniform(r,i,c):this.setUniform(r,c);break;case"shader-import":var l=t.getAttribute("name");o?this.shaderSketch.imports.push(l):this.shaderSketch.imports.splice(this.shaderSketch.imports.indexOf(l),-1);break;case"shader-texture":var s=t.getAttribute("name"),f=t.getAttribute("src"),v=t.getAttribute("blending"),u=t.getAttribute("wrapping");if(o){if(null==this.shaderSketch.getTexture(s)&&-1==this.loadingTextures.indexOf(s)){this.loadingTextures.push(s);var _=new Image;_.onload=function(){e.addTexture(s,_,{blending:v,wrapping:u,update:!1})},_.src=f}}else this.shaderSketch.deleteTexture(s);break;case"shader-canvas-texture":var d=t.getAttribute("name"),p=t.getAttribute("selector"),h=t.getAttribute("blending"),y=t.getAttribute("wrapping");if(o){var x=document.querySelector(p);if(null==x)break;this.addTexture(d,x,{blending:h,wrapping:y,update:!0})}else this.shaderSketch.deleteTexture(d);break;case"shader-typography":var g,m,b,w,z,P,S,E=t.getAttribute("name"),k=t.textContent,T=null!==(g=parseFloat(t.getAttribute("font-size")))&&void 0!==g?g:24,D=null!==(m=t.getAttribute("font-family"))&&void 0!==m?m:"sans-serif",A=null!==(b=t.getAttribute("font-style"))&&void 0!==b?b:"normal",C=null!==(w=t.getAttribute("font-weight"))&&void 0!==w?w:"normal",O=null!==(z=parseFloat(t.getAttribute("text-wrap")))&&void 0!==z?z:1/0,R=null!==(P=t.getAttribute("text-align"))&&void 0!==P?P:"center",X=null!==(S=parseFloat(t.getAttribute("margin")))&&void 0!==S?S:0,I=t.getAttribute("blending"),j=t.getAttribute("wrapping");if(o){var U=a.generateTypographyCanvas({text:k,fontSize:T,fontFamily:D,fontStyle:A,fontWeight:C,textWrap:O,textAlign:R,margin:X});this.addTexture(E,U,{blending:I,wrapping:j,update:!1})}else this.shaderSketch.deleteTexture(E)}this.shaderSketch.shouldCompileProgram=!0}},{key:"render",value:function(){var n=this;this.mounted&&requestAnimationFrame((function(){n.render()})),this.updateSize(),this.shaderSketch.render()}},{key:"updateSize",value:function(){this.rect=this.getBoundingClientRect();var n=this.rect,e=n.width,t=n.height,o=this.width,r=this.height;e==o&&t==r||(this.width=e,this.height=t,this.canvasElt.width=e,this.canvasElt.style.width=e>=1?e:1,this.canvasElt.height=t,this.canvasElt.style.height=t>=1?t:1,this.shaderSketch.buffer.width=e,this.shaderSketch.buffer.style.width=e>=1?e:1,this.shaderSketch.buffer.height=t,this.shaderSketch.buffer.style.height=t>=1?t:1,this.shaderSketch.gl.viewport(0,0,e,t),this.setUniform("viewportSize",e,t))}},{key:"addUniform",value:function(){var n;(n=this.shaderSketch).addUniform.apply(n,arguments)}},{key:"getUniform",value:function(){var n;return(n=this.shaderSketch).getUniform.apply(n,arguments)}},{key:"setUniform",value:function(){var n;(n=this.shaderSketch).setUniform.apply(n,arguments)}},{key:"addTexture",value:function(n,e,t){var o=t.blending,r=t.wrapping,i=t.update;this.shaderSketch.addTexture(n,e,{blending:o,wrapping:r,update:i}),this.shaderSketch.shouldCompileProgram=!0,this.loadingTextures.indexOf(n)>-1&&this.loadingTextures.splice(this.loadingTextures.indexOf(n),1)}}])&&$(o.prototype,r),i&&$(o,i),l}(Q(HTMLElement));function an(n){return(an="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n})(n)}function cn(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function ln(n,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(e&&e.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),e&&sn(n,e)}function sn(n,e){return(sn=Object.setPrototypeOf||function(n,e){return n.__proto__=e,n})(n,e)}function fn(n){var e=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],(function(){}))),!0}catch(n){return!1}}();return function(){var t,o=un(n);if(e){var r=un(this).constructor;t=Reflect.construct(o,arguments,r)}else t=o.apply(this,arguments);return vn(this,t)}}function vn(n,e){return!e||"object"!==an(e)&&"function"!=typeof e?function(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}(n):e}function un(n){return(un=Object.setPrototypeOf?Object.getPrototypeOf:function(n){return n.__proto__||Object.getPrototypeOf(n)})(n)}customElements.define("fragment-shader",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-uniform",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-import",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-texture",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-canvas-texture",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-typography",function(n){ln(t,n);var e=fn(t);function t(){return cn(this,t),e.apply(this,arguments)}return t}(Y)),customElements.define("shader-sketch",rn)}]);